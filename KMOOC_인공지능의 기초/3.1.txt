안녕하세요? 서울대학교 컴퓨터공학과의 김건희입니다. 오늘은 인공지능의 기초 휴리스틱 탐색과 지역 탐색에 대한 주제로 말씀을 드리도록 하겠습니다.
지난 시간에 저희가 Depth-first search랑 Breath-first search라는 탐색 전략에 대해서 배웠습니다.
그 둘을 소개하면서 제가 그 두 가지는 Uninformed Search Strategies라고 말씀을 드렸는데요.
Uninformed라는 얘기는 문제를 정의하는 데 필요한 4가지 요소, 그 4가지 요소 외에 다른 정보는 전혀 주어지지 않은 상태에서 탐색을 수행하는 과정입니다.
이번 주차에서 다룰 내용은 그와는 반대로 문제정의 외에 다른 추가적인 정보가 있을 때 어떻게 그것을 활용하여 탐색을 더 용이하게 하느냐, 그거에 대해서 다루도록 하겠습니다.
이런 부가적인 정보를 많은 경우에 휴리스틱이라고 얘기를 합니다.
그래서 휴리스틱을 사용하는 Informed Search Strategies에서 기본 아이디어는 무엇이냐 하면, 우리가 노드를 펼쳐놓고 그 노드에 대해서 깊이 탐색을 하기 전에,
그 노드가 얼마나 우리 문제를 푸는 데 있어서 좋은 노드인지, 바람직한 노드인지를 판단해줄 수 있는 평가함수를 정의하자는 것입니다.
그래서 그 평가함수에 따라서 평가함수 값이 높은 노드부터 일단 더 깊이 펼치고 더 탐색을 해나가자. 이게 Informed Search의 기본 아이디어라고 할 수가 있겠습니다.
그래서 실제로 저희가 Fringe라는 용어를 사용했었죠. 그러니까 펼쳐지긴 했지만 아직 깊이 탐색하지 않은 노드들이 있을 때
그 노드들을 단순히 가장 얕은 노드부터 펼칠지, 혹은 가장 깊은 노드부터 펼칠지, 이런 식의 정해진 룰대로 하는 것이 아니라,
Evaluation function을 보고 가장 바람직한 노드부터 하나둘씩 펼쳐나가는 그런 탐색 전략이라고 말씀드릴 수 있겠습니다.
그래서 Informed search strategy 중에서 오늘은 특히 Greedy best-first search랑 A* search라는 가장 대표적인 방법에 대해서 말씀을 드리도록 하겠습니다.
그럼 우선 Greedy best-first search부터 말씀을 드리도록 하겠습니다.
이 문제는 지난 시간에 저희가 함께 다루었던 루마니아 문제입니다.
저는 Arad라는 도시에 있는데 내일까지 Bucharest에 가고자 하고요. 그리고 되도록 이면 최단 거리를 통해서 원하는 목적지에 도달하고자 합니다.
그런데 예를 들어서 저희의 추가적인 정보로 예를 들어 각 도시에서 Bucharest까지의 직선거리를 알 수 있다고 한번 가정을 해보죠.
직선거리라는 것은, 즉 문제정의에 꼭 있어야 되는 정보는 아니지만, 우리가 추가적으로 가지고 있는 정보입니다.
그럼 이 정보를 활용해서 저희가 더 나은 탐색 방법을 제안할 수 있다는 것입니다.
그래서 일단 Greedy best-first search에서는 저희가 조금 전에 말씀드린 평가함수를 휴리스틱 함수의 값을 그대로 활용을 합니다.
그러니까 조금 전의 예제 같은 경우에 저희가 휴리스틱 한 정보로서 각 도시에서 Bucharest까지의 직선거리를 알 수 있다고 했기 때문에,
도시를 하나하나씩 탐색해나갈 때 되도록이면 Bucharest까지의 거리가 가장 짧은 노드부터 하나씩 더 깊이 펼쳐나가는 게 낫겠죠.
그래서 저희는 Evaluation function으로 Heuristic Function을 쓰고, Heuristic Function은 직선거리이고, 그것을 기반으로 해서 하나하나씩 노드를 탐색하는 과정을 한번 적용을 해보도록 하겠습니다.
그러면 예제와 함께 다시 보도록 하죠. 저희가 지금 Arad라는 도시에 있습니다. Arad는 Bucharest까지 366㎞ 밖에 있는 도시죠.
지난번처럼 Arad에서 우리가 직접적으로 갈 수 있는 도시가 세 군데였습니다. Sibiu, Timisoara, Zerind이 3가지 도시가 있는데요.
그 중에서 휴리스틱으로 저희가 직선거리를 사용하기로 했지 않습니까? 그래서 그 평가함수 값으로서 휴리스틱 값이 직선거리를 활용을 하고자 합니다.
그래서 이 세 도시를 보시면 Bucharest까지의 직선거리가 가장 짧은 곳이 Sibiu입니다. 그래서 Sibiu를 더 깊이 탐색을 해나가게 되는 것이죠.
그러면 여기에서 보시다시피 Sibiu에서 바로 갈 수 있는 인접 도시들을 하나씩 나열을 했습니다. 그러면 4가지 도시가 도달 가능한 곳인데요.
그중에서 또 Heuristic Function을 활용을 해서 최단거리가 가장 가까운 도시가 어디인지 살펴보니, Fagaras라는 도시가 가장 가까운 것으로 밝혀졌습니다.
그러면 지금 여기에 아직 깊이 탐색하지 않는 노드가 총 6개가 존재하게 되는데, 이 6개 중에 Bucharest까지의 거리가 가장 짧은 Fagaras, 그 도시부터 더 탐색을 해나가게 되는 것입니다.
그럼 Fagaras의 주변 도시를 찾아보면, Sibiu라는 도시와 운이 좋게도 저희의 목적지인 Bucharest가 Fagaras에서 바로 도달할 수 있는 곳이었습니다.
그래서 이런 식으로 search를 해나가면 훨씬 더 빠르게 저희가 원하는 goal까지 도달할 수 있겠죠.
만약에 여러분이 Breadth-first search를 적용한다고 하면 Timisoara나 Zerind 같은 도시를 계속 탐색을 해나가야 될 텐데, 그럴 필요가 없었고요.
만약에 여러분이 Depth-first search를 적용했다고 하면 Arad에서 또다시 search해 나간다든지 그런 비효율적인 탐색 과정이 필요한데,
저희가 휴리스틱 함수를 활용을 해서 그 휴리스틱 함수 기반으로 가장 좋다고 생각되는 도시를 하나하나씩 펼쳐나감으로써 훨씬 더 목적지까지 빠르게 탐색해나갈 수 있는 것입니다.
그래서 이와 같은 방법이 Greedy best-first search라고 보실 수가 있겠습니다.
그럼 이제 첫 번째 알고리즘에 대해서 말씀을 드렸고요. 그다음 Informed Search Strategies의 가장 많이 사용되는 것 중에 하나가 A* 알고리즘이라고 합니다.
그래서 A* Search에 대해서 좀 더 깊이 말씀을 드리도록 하겠습니다. A* Search는 Evaluation function을 정할 때 추가적으로 한 가지 정보를 더 활용을 합니다.
여기에서는 g(n)이라고 되어 있는데, g(n)이라는 건 n 노드까지 오는 데 걸린 시간이었습니다.
그래서 best-first search에서는 f(n)은 h(n)과 동일하다고 활용을 했는데, 여기에서는 g(n)이라는 정보까지 더한 값을 평가 함수로 활용하겠다는 것입니다.
그래서 여기에서 g(n)이라는 건 조금 전에도 말씀드렸다시피 노드 n까지 오는 데 걸린 cost, 비용이었고요. h(n)은 현재 노드 n에서 목적지까지 실어야 할 비용입니다.
그런데 여기에서 중요한 거는 estimated cost라는 거죠. 그러니까 우리가 실제로 현재 노드 n에서 goal까지 얼마의 비용으로 가는지는 탐색을 해봐야 아는 것이고요.
여기에서 h(n)이라는 것은 우리가 조금 전에 말씀드린 Heuristic Function을 이용을 해서 어느 정도 정확한 값은 아니지만 가늠할 수 있는 값으로 사용을 한 것입니다.
그래서 조금 전의 예제에서는 직선거리를 활용을 했었죠.
그래서 결국에는 특정 노드가 얼마나 좋은지, 안 좋은지, 그 노드를 펼쳐야 될지, 말아야 될지를 결정하는 평가 함수로 g(n)과 h(n)을 합한 값을 활용을 하게 됩니다.
그래서 아이디어를 보시면 기본적으로 현재 노드들 중에서 goal까지 도달하는 데 가장 빠른 노드를 펼치는 동시에 그리고 또 하나 추가된 내용은
그 노드까지 가는 데 있어서 이미 비싼 비용을 치렀다고 하면, 그 노드를 더 이상 펼치지 말고, 비용이 더 작은 노드를 중점적으로 활용하자는 것입니다.
그러니까 어떤 노드까지 오는 데 걸린 cost, 그 노드로부터 goal까지 가는 데 걸린 예측된 cost값을 더한 그 값을 활용을 해서 이제 노드를 펼쳐나가겠다.
그게 A* 알고리즘의 기본 아이디어라고 할 수 있겠습니다.
그래서 여기에서 Heuristic Function에 대해서 다시 한 번 말씀을 드리는데, Heuristic Function은 어떻게 보면 우리가 실제로 계산해야 될 값은 아니지만,
그것을 가늠한, estimated한 값이라고 보시면 되겠습니다. 그래서 실제 여러분이 Heuristic Function을 어떻게 정할까가 실제 탐색 문제에서 되게 어려운 문제이긴 한데요.
Heuristic Function을 좋은 거를 만약에 쓴다고 하면, 그 Heuristic Function을 활용하면 더 빨리 탐색을 할 수 있겠죠.
그렇지만 Heuristic Function 중에 별로 안 좋은 휴리스틱을 쓰면 그만큼 더 안 좋아질 테고요.
많은 경우에 여기에는 트레이드오프 관계가 있습니다.
그러니까 우리가 Heuristic Function을 만들려고 하면 실제 문제를 더 잘 이해하고, 더 많은 정보를 활용해서 그래야만 더 좋은 휴리스틱 함수를 만들 수가 있을 텐데요.
그렇다고 하면 휴리스틱 함수를 만드는 데 걸리는 노력, 그리고 그 함수를 썼을 때 optimal 값을 더 빠르고 정확하게 찾을 수 있는 노력, 그 둘 사이에는 트레이드오프 관계가 있다는 것입니다.
그래서 많은 경우에 휴리스틱 함수는 문제에 대한 전문가가 정확히 문제를 풀기에 앞서서
이 문제를 푸는 데 있어서 이런, 이런 정보가 유용할 것이라는 어떻게 보면 guess, 예측을 기반으로 해서 정의를 하게 되는데,
그거는 좋은 휴리스틱 함수를 정의하는 노력, 그리고 그 함수를 활용을 해서 goal을 찾는 노력 간 트레이드오프 관계가 있다. 이렇게 보시면 되겠습니다.
그러면 A* 알고리즘에 대해서 말씀을 드리도록 하겠습니다.
여기 보시다시피 앞에 있는 숫자는 f(n)입니다. evaluation 함수고요. 첫 번째 함수는 g(n)이죠. 그러니까 이 노드까지 오는 데 걸린 시간이 cost입니다.
그리고 두 번째 더하는 숫자는 h(n)입니다. 이거는 우리 예제에서 Arad에서 Bucharest까지 직선거리였죠.
이 경우에는 처음에 초기노드, Arad가 초기노드이기 때문에 g(n) 값은 여기에서 0이 됩니다. 그러면 Arad 주변에 갈 수 있는 도시가 조금 전에 보셨다시피 3개의 도시가 있었죠.
예전에는 어떻게 보면 각 도시에서 goal까지의 최단거리를 가지는 도시를 먼저 살펴봤다고 한다면,
여기에서는 그 도시까지 가는 데 걸린 cost, 그리고 그 도시에서 goal까지의 최단거리, 그거를 활용하게 됩니다.
그래서 보시면 Sibiu가 g(n)이랑 h(n)의 합에 가장 적기 때문에 Sibiu라는 노드부터 탐색을 진행하게 됩니다.
그럼 Sibiu 주변에 4개의 도시가 있었고요. 그러면 처음 Fringe에는 아직 탐색하지 않은 노드가 총 6개가 있습니다. 6개가 있는데 마찬가지로 각각에 대해서 f(n)을 계산을 한 것입니다.
그래서 각 노드 밑에 있는 숫자 중에 첫 번째 숫자는 초기 state에서 현재 state까지 오는 데 걸린 cost고요.
두 번째는 그 노드에서 goal까지 거리입니다. 그래서 이 둘을 다 합해 보니까 가장 cost, f(n)이 작은 도시가 Vilcea입니다. 이 경우에는 총 f(n)이 413이라는 값을 가지게 되었습니다.
그래서 6개 주의 가장 작은 값을 가지는 노드입니다. 그래서 이 노드 주변에 있는 도시들을 다시 한 번 살펴봅니다.
살펴보면 이제 또 3개의 도시가 나오는데요. 그 각각의 3개의 도시에 대해서 f(n)을 다시 다 구해봅니다. 그러면 아직 탐색하지 않은 노드가 총 8개가 있는데, 그 8개 중에 마찬가지로 f값이 제일 적은 도시를 선택을 하게 됩니다.
이 경우에는 Fagaras라는 도시가 f값이 가장 작기 때문에 이 노드에 대해서 또 탐색을 시작합니다.
그런데 조금 전에 예제에서 보셨다시피 Fagaras에서 Bucharest까지 갈 수 있는 path가 존재했었죠.
그래서 앞에 Greedy best-first search에서는 Arad에서 Sibiu, Fagaras, Bucharest까지 가는 것을 최단거리로 예측을 했는데요.
마찬가지로 그 노드를 저희가 발견을 했습니다. 그렇지만 A* Search 에서는 여기에서 그냥 끝내는 게 아니라, 혹시라도 더 좋은 솔루션이 있는지 찾는 과정을 한 번 더 거치게 됩니다.
그러니까 지금 말씀드린 이 path를 통해서 Bucharest까지 가는 데 걸린 f(n)은 450이었습니다.
그러면 예를 들어서 옆에 있는 Sibiu라는 도시로 가는 데 값을 한번 비교해보죠. 이 값은 591입니다. 따라서 Sibiu는 더 이상 탐색할 필요가 없습니다.
왜냐하면 여기에서도 탐색해봐야 지금까지 찾은 솔루션 450이라는 값보다는 항상 클 거기 때문에 Sibiu는 더 이상 탐색을 하지 않아도 좋습니다.
Arad도 646인데 450보다 큰 수이기 때문에 서치를 하지 않아도 되고요. 마찬가지로 450이라는 값보다 더 큰 값을 가지는 노드는 더 이상 찾을 필요가 없습니다.
하지만 여기 Arad, Sibiu, R.V, pitesti로 가는 path를 한번 보죠. 여기에서는 f값이 417입니다. 417은 어쨌든 450보다 작은 숫자죠.
그래서 이 노드를 따라 가면 혹시라도 더 짧은 거리를 통해서 Bucharest까지 갈 수 있는 여지가 있기 때문에 이 노드에서는 한 번 더 탐색을 수행하게 됩니다.
그래서 Pitesti 주변에 도시를 하나씩 펼쳐 보는데, 그 인접 도시로서 Bucharest까지 존재를 했죠. 그런데 인접 도시로 가는 이 path를 통해서 Bucharest까지 가는 함수 f 값은 418입니다.
이 418이라는 값은 우리가 그 전에 찾은 Arad, Sibiu, Fagaras, Bucharest path에 비해서 더 작은 값을 가지게 됩니다.
따라서 어떻게 보면 A* 알고리즘을 통해서 우리가 기존에 찾은 솔루션보다 더 나은 솔루션을 찾았다. 이렇게 보실 수가 있습니다.
그래서 이게 어떻게 보면 A* Search와 Greedy best-first search와의 차이점인데요. A* 알고리즘을 쓰면 많은 경우에 더 optimal한 솔루션을 찾을 수 있다는 장점이 있습니다.
그러면 여러분이 자연스럽게 궁금해질 질문 중 하나가 이것입니다.
언제 A* 알고리즘을 사용했을 때 최적의 솔루션을 찾을 수 있는지 그게 아마 궁금하실 거고요.
그것에 대해서 얘기하기 위해서 하나의 정의를 소개시켜드리고자 합니다. 휴리스틱 함수에 대한 정의인데요. 휴리스틱 함수가 admissible하다고 얘기하는 경우가 있습니다.
이거는 어떤 경우냐 하면, 우리가 사용하는 휴리스틱 함수 값이 실제 그 노드에서 goal까지의 true cost보다 항상 작거나 같을 경우를 우리가 admissible이라고 합니다.
그러니까 우리가 항상 under estimate 한다는 거죠. 실제 값보다.
우리의 휴리스틱 함수가 실제 cost보다 항상 under estimate, 실제 값보다 항상 작거나 같게 예측을 하면 그 휴리스틱 함수를 admissible하다고 얘기를 합니다.
우리가 조금 전에 본 예제에서 휴리스틱 함수로서 어떤 도시와 goal까지의 직선거리를 활용했습니다. 그런데 아시다시피 직선거리는 언제나 실제거리보다는 작겠죠.
실제거리는 도시와 도시 사이에 나 있는 도로를 따라서만 가야 되기 때문에 항상 직선거리에 비해서는 실제거리가 더 길게 됩니다.
그렇기 때문에 지금 저희가 본 루마니아 예제에서의 휴리스틱 함수는 admissible하다고 할 수 있겠죠.
그래서 만약에 여러분의 휴리스틱 함수가 admissible하다고 했을 때 A* 알고리즘을 활용을 한다면 언제나 최적의 솔루션을 찾을 수가 있습니다.
이게 되게 중요한 결과라고 할 수가 있겠죠. 그러니까 여러분이 휴리스틱 함수를 적용을 하면 많은 경우에 더 나은 솔루션을 더 빠르게 찾을 수가 있고요.
그리고 만약에 그 휴리스틱 함수가 admissible하다는 그 조건을 만족을 한다면 여러분은 A* 알고리즘으로 항상 최적의 솔루션을 구할 수가 있습니다.
그러면 다음 슬라이드에서는 왜 admissible 하면 A* 알고리즘이 optimal한 솔루션을 주는지 그거에 대해서 간단한 증명을 살펴보도록 하겠습니다.
이거는 어떻게 보면 개념적인 증명이라고 할 수가 있겠고요. 여기는 3가지 정의가 일단 있습니다.
첫 번째, G2라는 건 G2라는 그런 예도 나와 있다시피 suboptimal goal이다. suboptimal goal라는 거는 G2가 goal이긴 한데, 최적의 goal은 아니라는 것입니다.
그러니까 start부터 G2까지 간다고 하면, 이 path로 간다고 하면, 여러분이 Bucharest라는 도시에 갈 수 있긴 하지만, 그런데 이게 최적의 path가 아닌 경우를 G2라고 합니다.
그리고 여기에서 G라고 하는 노드는, 이거는 최적의 path를 통해서 goal을 도달한 경우라고 볼 수가 있겠습니다.
그리고 여기 n이라는 노드가 있는데, n이라는 노드는 아직 펼쳐지지 않은 노드입니다.
fringe에 있어서 아직 펼쳐지지 않은 노드인데, n을 만약에 G까지 가는 optimal path에 속해져 있는 노드라고 한번 가정을 해보죠.
그러니까 n은 아직 펼쳐지지 않았지만 얘는 optimal path상에 존재하는 노드다. 이렇게 한번 가정을 해보죠.
그러면 일단 여러 가지 스텝을 통해서 증명을 해보도록 하겠습니다. 첫 번째 증명은, 첫 번째 결론은 f(G2)가 g(G2)랑 똑같다는 뜻입니다.
왜냐하면 G2는 아까 말씀드렸다시피 goal이기 때문에 G2에서의 Heuristic Function의 값은 0입니다.
그러니까 G2에서 goal까지의 estimate distance는 G2가 goal이기 때문에 당연히 0이 되어야 하겠죠. 그래서 G2에서는 f값과 g값이 동일하게 됩니다.
그러면 이제 g(G2)랑 g(G)를 한번 비교를 해보죠. 여기에서는 항상 G2의 g값이 G에서의 g값보다 크게 됩니다.
왜냐하면 조금 전에 우리가 말씀을 드렸다시피 G2는 suboptimal goal이고, G는 optimal goal입니다.
그런데 이제 g라는 함수가 시작점에서 그 노드까지 가는 데 걸린 cost이기 때문에 당연히 suboptimal goal의 G값보다는 실제 optimal의 G값이 훨씬 크게 되죠.
그래서 두 번째 조건도 우리가 쉽게 알아낼 수가 있습니다. 그리고 세 번째 결과는 G에서의 f 값과 g 값은 동일하다는 것입니다.
왜냐하면 조금 전에 말씀드린 대로 g는 goal이기 때문에 여기에서의 휴리스틱 함수값은 0이 됩니다. 따라서 이거를 얻을 수가 있겠고요.
그러면 위에 밝혀진 3가지 룰을 통해서 우리가 f(G2)는 f(G)보다 크다는 것을 알 수가 있겠습니다.
왜냐하면 f값이라는 것은 g랑 h의 합이었죠. 따라서 G2에서의 g값이, G에서의 g값보다 크고, h값은 둘 다 0이기 때문에 당연히 f값을 비교해보면 G2에서의 f값이 G에서의 f값보다 크게 됩니다.
그래서 지금 말씀드린 정의에 의해서 하나하나씩 밟아가면서 결국에는 f(G2)가 f(G)보다 크다는 결론을 도출할 수가 있습니다.
그럼 이제 계속 이 유도를 한번 진행해나가도록 해보죠. 여기에서 첫 번째 수식은 전 슬라이드의 결론을 그냥 단순히 카피를 한 것입니다.
그리고 두 번째 수식의 경우에는 저희가 h가 admissible하다고 가정을 했기 때문에 h(n)은 실제 n에서의 true cost보다는 항상 작거나 같게 됩니다.
그리고 세 번째 수식은 두 번째 수식으로부터 바로 올 수가 있는데, 두 번째 수식에서 양쪽에 g(n)이라는 값을 동시에 더하게 됩니다.
그래서 부등호의 경우에는 똑같은 수를 양쪽에 더하면 그 부등호 방향은 바뀌지 않기 때문에 세 번째 결론도 쉽게 얻을 수가 있고요.
그다음에 마지막 결론은 저희가 말씀드렸다시피 n이라는 노드는 시작 노드에서 g라는 goal 노드까지 가는 중간에 있는 노드이기 때문에 f(n)은 항상 f(G)보다 작거나 같아야 합니다.
그러니까 cost는 노드를 가면 갈수록 항상 커지거나 같아야만 하기 때문에 이와 같은 결론을 얻을 수가 있겠죠.
그래서 결국에는 첫 번째 수식과 네 번째 맨 마지막 수식을 한번 활용을 해보죠.
그래서 f(G2)가 f(G)보다 항상 큽니다. 그런데 동시에 f(n)은 f(G)보다 항상 작거나 같기 때문에 결국에는 f(G2)는 f(n)보다 항상 크다는 것을 알 수가 있습니다.
그러니까 A* 알고리즘을 우리가 활용한다면 f값을 이용해서 저희가 어떤 노드를 펼칠지를 결정을 하는데,
여기에서 알 수 있는 사실은 G2를 n 대신에 펼치는 일은 절대 일어나지 않는다는 것입니다.
A* 알고리즘은 f 값을 활용을 해서 f 값이 작은 노드부터 하나씩 펼쳐지게 되는데,
f(G2) 그러니까 suboptimal한 노드는 n, 그러니까 optimal한 path 상에 있는 노드 대신에 펼쳐지는 경우가 절대 없다는 것입니다.
그래서 이것을 계속 반복을 하다 보면 결국에는 저희가 goal, 노드 g까지 도달하는 데 있어서 노드 G2를 펼치는 일은 절대 일어나지 않는다.
이것을 저희가 증명을 통해서 확인할 수 있었습니다. 그래서 본 수업에서는 저희가 Informed Search 알고리즘에 대해서 말씀을 드렸고요.
이 경우에는 저희가 문제를 정의하는 데 필요한 4가지 요소 외에 다른 정보가 주어졌다고 가정을 하고요. 그리고 그 정보를 Heuristic Function을 통해서 얻게 됩니다.
그리고 Heuristic Function은 트레이드 오프 관계가 있어서 좋은 Heuristic Function을 가지고 있으면 더 나은 솔루션을 쉽게 찾을 수 있지만,
그런데 좋은 Heuristic Function을 찾는다는 것 자체, 그것을 정의한다는 것 자체가 더 많은 노력이 필요하겠죠. 그래서 그 사이에는 트레이드 오프 관계가 있다는 것이고요.
그리고 A* 알고리즘은 기본 아이디어는 그 노드까지 오는 데 걸린 cost,
그리고 그 노드에서 goal까지 가는 데 예측된 휴리스틱 함수에 cost가 합쳐서 그 합이 최소가 되는 노드부터 하나씩 펼쳐나간다는 것이고요.
그래서 A* Search가 더 나은 알고리즘, 그러니까 Greedy best-first search보다는 더 낫다는 것을 여러분이 쉽게 이해를 하실 거고요.
그리고 A* 알고리즘 같은 경우에는 저희 Heuristic Function이 admissible하다.
이런 조건을 만족한다면 항상 A* 알고리즘은 optimal solution을 저희가 Tree search를 통해서 찾을 수 있다. 그것을 증명을 하였습니다.
그러면 오늘 수업은 이렇게 요약을 할 수 있을 것 같고요. 그러면 다음 시간에 다시 만나 뵙도록 하겠습니다.