안녕하세요? 서울대학교 컴퓨터공학부와 김건희입니다. 인공지능의 기초, 이번 수업에서는 ‘문제해결 및 탐색전략’이라는 주제로 말씀드리도록 하겠습니다.
인공지능에서 문제를 어떻게 정의하고, 그 문제를 어떻게 풀어내는지를 다루고요. 그리고 많은 경우에 인공지능의 문제라는 건 탐색을 통해서 해결을 하게 되어 있는데요.
그래서 어떤 탐색 아이디어를 가지고 문제를 풀게 되는지에 대해서 자세히 말씀드리도록 하겠습니다.
인공지능의 문제를 소개시켜드리기 위해서 간단한 예제를 먼저 말씀드리도록 하겠습니다. 이 예제는 Romania 예제라고 많이 알려진 문제고요.
간단히 문제에 대해서 말씀을 드리면, 제가 Romania에서 휴가를 보내고 내일 Romania를 떠나게 되었습니다.
그런데 Bucharest라는 도시로 돌아가서 비행기를 타야 되는데요.
여기서 문제는 내가 현재 Arad라는 도시에 있었을 때 어떻게 하면 Bucharest까지 갈 수 있는지 그 문제를 예제로 한번 같이 풀어보도록 하겠습니다.
문제를 정의하기 위해서는 일단 초기 상태와 목표를 정의해야 되는데, 이 문제의 경우에는 Arad라는 도시가 초기 상태가 될 테고요. 그다음에 Bucharest라는 곳이 최종 goal state가 될 것입니다.
그리고 여기서 state라고 말씀을 드리는 건 각 도시들을 state로 정의할 수 있겠고요.
action이라는 건 그 state에서 어떤 state로 가는, 그러니까 운전을 통해서 도시 사이를 이동하는 걸 action이라고 정의할 수 있겠죠.
그래서 결국에 이 문제라는 건 제가 Arad라는 state에서 시작해서 제가 여러 개의 action을 통해 도시를 옮겨 다니면서
결국에는 Bucharest까지 가는 전체 저의 action, sequence를 solution, 해라고 정의를 할 수 있겠습니다.
그래서 결국에는 이런 주어진 문제를 해결하는 여러 solution이 가능합니다. 이 예제에서는 Arad에서 Bucharest까지 가는 수많은 경로가 존재하게 될 테고요.
그 경로 하나하나가 이 문제를 해결하는 해가 될 것입니다. 하지만 많은 경우에 이 수많은 해들 중에서 최고의 해를 찾는 게 목적이 되는 경우가 많고요.
최고의 해라는 건 정의하기에 따라 다르겠지만, 일반적으로 생각할 수 있는 건 최단거리를 이동해서 Bucharest까지 도달하는 경로를 최고의 해라고 정의할 수 있겠습니다.
인공지능에서 문제를 정의하기 위해서는 크게 4가지 구성요소가 필요합니다. 그 구성요소에 대해서 하나하나씩 말씀을 드리도록 하겠습니다.
좀 전에 말씀드렸다시피 상태를 나타내는 state와 action, 이 두 가지가 가장 핵심이 되는 요소라는 건 말씀을 드렸는데요.
그거로부터 훨씬 더 정교화된 4개의 구성요소를 말씀드리도록 하겠습니다.
첫 번째 요소는 초기상태입니다. 그러니까 이 문제를 푸는 데 있어서 첫 상태를 얘기한다고 할 수 있겠고요.
Romania Example에서는 Arad라는 도시에 있는 그 상태가 초기상태라고 쉽게 정의를 할 수 있겠습니다.
두 번째로는 가능한 action들, 가능한 행동들을 정의하는 거라고 할 수 있겠는데요. 여기서 보면 Successor라는 함수를 정의하였습니다.
이 Successor라는 함수는 x라는 input을 받아서 action과 successor라는 pair가 이제 output으로 나오는 함수라고 정의를 할 수 있겠고요.
좀 전에 말씀드린 Romania 예제에서 보실 수 있다시피 현재 제가 Arad라는 state에 있다고 했을 때 Arad라는 state에서 할 수 있는 action들이 여러 도시로 가는 게 하나하나가 action이 되겠죠.
그래서 제가 만약에 Zerind라는 도시로 가는 action을 취한다고 하면, 그거의 결과로 Zerind라는 successor state로 도달하게 되는 것이죠.
그래서 action이라는 건 결국에 어떤 상태에서 다른 상태로 이동하기 위한 행동이라고 정의를 할 수가 있겠습니다.
세 번째 구성요소는 Goal test입니다. 그러니까 쉽게 얘기해서 현재 상태가 우리가 문제를 풀고자 하는 목적, goal에 도달했는지 아닌지를 판단해주는 일종의 테스트라고 보시면 되겠습니다.
그래서 좀 전에 말씀드린 Romania 예제에서는 Bucharest까지 가는, 그러니까 Bucharest라는 state 자체가 goal이 되겠죠.
그래서 만약에 제가 Bucharest라는 상태에 현재 도달했다. 그러면 Goal test를 통과했다고 할 수가 있겠죠.
그런데 문제에 따라서는 이런 식으로 하나의 state를 goal로 정의할 수도 있지만, 많은 경우에 state를 하나로 정의하기보다는 조건으로 정의하는 게 더 좋은 경우도 있습니다.
예를 들어서 여러분이 체스 게임을 문제로 정의를 해서 푼다고 했을 때 체스에서는 결국 상대방이 왕을 잡는 것이 목적이 될 테고요. 그게 goal이 될 테고요.
그래서 상대방의 왕을 잡는 경우는 아주 많기 때문에 그 state를 일일이 나열하는 건 매우 힘들고요.
단지 어떤 경우에 왕을 잡게 되는지 그 조건을 기술한 함수로서 Goal test를 수행할 수가 있겠습니다. 이런 식으로 명시적으로 Goal test를 정의할 수도 있고요. 비명시적으로도 가능합니다.
네 번째 구성요소는 경로 cost입니다. Path cost라고 정의를 하는데요.
이건 뭐냐 하면, 제가 어떤 state에서 어떤 action을 취해서 또 다른 state로 간다. 이걸 하나의 경로라고 할 수 있는데, 이 경로를 수행하는 데 있어서의 비용을 Path cost로 정의할 수 있겠습니다.
그래서 여기서는 Step cost라는 걸 하나 정의했는데요. 이 Step cost라는 건 3개의 input을 받습니다.
그러니까 Step cost는 x라는 state에서 a라는 action을 취해서 y라는 state로 갔을 때의 cost를 c(x, a, y)로 정의할 수 있겠죠.
그리고 이런 Step cost는 많은 경우에 0보다 크거나 같은 식으로 정의를 합니다.
그러니까 제가 어떤 action을 하는 경우에 비용이 발생하는 경우가 많고요. 최상의 경우에는 비용이 하나도 없는 경우도 있겠죠.
그렇지만 비용이 마이너스가 되는 경우는, 물론 그것도 여러분이 정의하기에 따라서 가능할 수는 있지만 일반적으로 ‘Path cost는 0보다 크거나 같다.’ 그런 식으로 정의를 하게 됩니다.
그래서 좀 전에 말씀드린 Romania 예제에서는 어떤 도시에서 어떤 action을 취해서 다른 도시로 갔다고 했을 때
그 도시들 사이의 거리가 Path cost로 주어지는 경우가 Step cost로 주어지고, 그래서 총 action 결과로서의 Path에 대해서 비용을 정의할 수 있겠죠.
solution이라는 건 Initial state에서 수많은 action을 통해서 goal state로 가게 될 텐데, 그 action들의 연속을 인공지능 문제에서의 해라고 정의할 수 있겠습니다.
인공지능 문제를 정의하는 데 있어서 중요한 것 중에 하나가 state를 어떻게 정의하느냐? 이것입니다.
실제로 우리가 살고 있는 세상은 생각보다 매우 복잡합니다. 그러니까 제가 만약에 Arad라는 도시에서 Bucharest까지 가는 방식은 매우 다양하고요.
그게 단순히 action 몇 개로만 할 수 있는 일도 아닙니다. 그렇지만 많은 경우에 실제 문제를 모델링을 통해서 일종의 abstraction, 추상화 과정을 통해서 먼저를 정의하게 됩니다.
추상화라는 건 여러분이 실제 문제를 모델링 하는 데 있어서 실제 문제보다 이해하기 쉽게 문제를 변환하는 과정이라고 할 수가 있겠습니다.
한 가지 예로 좀 전에 Romania 예제에서 각 도시를 state라고 정의했는데, 실제로 제가 Arad라는 도시에 있다는 것 자체는 수많은 경우가 있고, 수많은 복잡한 상황이 있을 텐데,
그냥 그 모든 상황을 하나의 state로 abstraction, 그러니까 추상화를 했다고 보실 수가 있겠죠.
그리고 action도 마찬가지로 추상화를 통해서 우리가 좀 전에 문제를 정의했다고 할 수 있는데요.
우리가 특정 도시에서 다른 도시로 간다는 action이라는 건 매우 복잡한 과정이 될 텐데, 그 복잡한 과정을 그냥 하나의 action으로 추상화했다고 보실 수가 있겠습니다.
마찬가지로 이런 추상화를 통해서 문제를 정의하게 되면 그 solution 자체도 어떻게 보면 매우 추상화된 해라고 할 수 있겠죠.
어떻게 보면 도시의 연속이 일종의 solution이 될 텐데, 그게 그렇게 간단한 문제는 아니고 현실에서는 그게 매우 복잡한 상황이지만
우리가 추상화를 통해서 해와 문제를 매우 간단하게 그리고 이해하기 쉽게 바꿨다고 보시면 되겠습니다.
그래서 결국에는 abstraction이라는 건 우리가 원래 문제, 그러니까 Arad에서 Bucharest까지 가는 원래 문제를 추상화를 통해서 좀 더 이해하기 쉽게 만드는 과정이라고 보시면 되겠습니다.
그래서 다른 문제에 대해서도 이와 마찬가지로 4개의 중요한 구성요소로 표현을 할 수 있습니다. 이건 많이 아시다시피 8-puzzle이라고 알려진 문제인데요.
여기 보시면 가운데 빈칸이 존재하죠. 빈칸이 존재한다는 건 우리가 이 빈칸의 주변에 있는 4개의 말 중에 하나를 이 가운데 영역으로 움직일 수 있다는 걸 의미합니다.
우리가 어떤 번호를 선택해서 그걸 빈 공간으로 움직이는 것 자체가 action이라고 정의할 수 있겠죠.
그리고 state라는 건 여기서는 어떻게 정의를 했느냐 하면, 1~8의 숫자가 배열된 상태를 하나의 state로 정의를 하였습니다.
그래서 Initial state는 왼쪽에 보이다시피 여러 숫자가 무작위로 배열된 상태고요.
우리가 도달하고자 하는 Goal state는 1번부터 8번까지 아주 정렬이 잘된 상태로 바꾸는 것이 Goal state라고 할 수 있겠죠.
그리고 여기서 중요한 Path cost는 뭐냐 하면, 많은 경우에 우리가 최적의 solution을 얻는다는 건 최단시간 안에 이 퍼즐을 풀어내는 거기 때문에
그렇다고 하면 말 하나를 움직이는 게 똑같은 시간이 걸린다고 가정하면 하나의 움직임을 1이라는 Path cost로 정의할 수 있겠죠.
만약에 이런 Path cost로 정의를 하고 이 Path cost대로 문제를 푼다면, 우리가 최소한으로 빈칸을 움직여서 Goal state로 도달하는 해를 구한다고 보실 수가 있겠죠.
이거는 Bucharest 예제와 또 다른 인공지능에서의 문제를 이런 식으로 정의할 수 있다는 것이고요. 이외에도 수많은 문제를 지금 말씀드린 4가지 요소로 여러분이 한번 정의를 해볼 수가 있겠죠.
그러면 많은 경우에 이와 같은 해를 구하는 과정을 Tree Search라는 알고리즘을 통해서 해결을 하게 됩니다. Tree라는 건 아시다시피 일종의 나무처럼 생긴 데이터 구조를 말하는데요.
어떤 특정 노드가 있고, 그 노드에 여러 가지 가능성이 있는 노드들을 연결하고, 그 각각의 노드에 대해서 또 가능성이 있는 state를 나열합니다.
그러다 보면 그게 Tree와 같은 모양으로 갖추어졌다고 해서 Tree Search Algorithms이라고 말을 합니다. 그래서 결국에 Initial state가 Tree의 루트, 그러니까 꼭대기가 되고요.
거기서 갈 수 있는 다양한 state가 그 밑의 자식 노드가 될 테고요. 그 자식 노드로부터 또 갈 수 있는 state가 여러 개 있을 텐데요.
거기서부터 또 노드들을 펼쳐나가고 펼쳐나가다 보면, 결국 우리가 하나의 Tree Search를 통해서 Bucharest라는 state까지 가는 그런 solution을 찾을 수 있겠죠.
그런 식으로 Tree라는 데이터 구조를 이용해서 문제를 해결하는 과정을 Tree Search Algorithms이라고 정의를 할 수 있겠습니다.
그래서 현재 state부터 시작해서 그 state로부터 도달할 수 있는 state를 찾아내고, 그 state로 가서 또 그 state에서 갈 수 있는 여러 state를 펼치는 식으로 하나하나씩 state를 펼쳐나가면서,
그러니까 Tree를 점점 펼쳐나가면서 solution을 찾는 과정을 진행하게 될 것입니다.
이건 좀 전에 말씀드린 Romania 예제로부터 Tree Search를 어떻게 적용할 수 있는지를 예제로 보여드린 것입니다.
좀 전에 말씀드렸다시피 우리가 현재 Arad라는 도시에 있습니다. 그리고 city map, 그러니까 지도를 통해서 보시면 아시겠지만 Arad에서 도달할 수 있는 도시가 총 3군데가 있습니다.
그렇다면 Arad를 Tree의 루트라고 했을 때 거기서부터 펼쳐질 수 있는 노드는 이와 같이 3가지 노드가 가능합니다.
그러면 이 각각의 3가지 노드에 대해서 마찬가지로 인접한 노드들을 하나하나씩 찾아내면 거기서부터 또 도달할 수 있는 노드를 Tree 형태로 이와 같이 찾아갈 수 있을 것입니다.
그래서 이 과정을 계속 반복하다 보면 결국 Bucharest라는 노드가 나올 텐데, 그렇다면 그 루트부터 그 state까지의 Path를 만든다고 하면 그 Path 하나가 solution이 되겠죠.
그런 식으로 해서 Tree Search Algorithms을 통해서 우리가 정의한 인공지능 문제를 해결하게 됩니다.
그래서 지금까지 말씀드린 내용을 정리하자면, state space, 그러니까 모든 가능한 state 공간을 다 펼치고 펼치다 보면 그게 하나의 나무, Tree라는 구조를 가지게 된다는 말씀을 드린 거고요.
그다음에 저희의 Initial state, 그러니까 초기조건, 초기상태라는 건 Tree라는 데이터 구조에서 루트, 그러니까 제일 꼭대기죠? 제일 꼭대기에 위치하게 되고요.
각 노드는 여기서 보시다시피 도시 이름들이 적혀 있는데, 각 노드는 state를 나타냅니다. 이 Tree상에서의 action이라는 건 각각의 edge들을 action이라고 정의할 수 있겠죠.
그러니까 Arad라는 state에서는 3개의 action이 가능한 겁니다.
Sibiu라는 도시로 갈 수 있는 action, Timisoara라는 도시로 갈 수 있는 action, Zerind라는 도시로 갈 수 있는 action. 이렇게 3개가 존재하는 것이고요.
각 action은 결국 일종의 Tree에서의 branch, 가지를 생성하게 됩니다. 그래서 결국에 저희가 Arad부터 시작해서 3개를 펼치고요.
그럼 이제 3개 중에서 우리가 그다음으로 펼쳐야 될 노드가 뭔지를 결정해야겠죠.
만약에 우리가 Sibiu라는 도시부터 탐색을 해나가겠다. 그렇게 하면 Sibiu에서 도달할 수 있는 state를 펴나가게 되는 것이죠.
그런 식으로 탐색이라는 건 결국 state를 펼치고, 그 중에 어느 state부터 펼칠지를 결정해서 그 state로 가서 또 펼치는 과정을 반복함으로써 Goal state를 찾는 과정이라고 보실 수 있겠습니다.
그러면 여기서 보시면 좀 전에 말씀드렸다시피 탐색을 하기 위해서는 전략이 필요합니다.
그러니까 첫 문장에 나와 있다시피 전략이라는 건 무엇이냐 하면, 우리가 각각의 노드를 펼쳐나가야 되는데 펼쳐나갈 때 어떤 순서로 펼쳐나갈 것이냐? 그걸 정의한다고 할 수 있겠습니다.
앞 슬라이드에서 보시면, 저희가 Arad에서 3개의 노드를 펼쳤고요. 그다음에 이 3개 중에서 어떤 노드부터 펼칠 것이냐?
만약 Sibiu라는 도시를 선택하면 다시 4개의 노드가 나오는데, 그러면 우리가 아직 펴보지 않은 노드가 6개 존재하게 되겠죠.
그러면 이 6개 중에 또 뭘 펼칠 거냐? 그런 전략을 탐색 전략이라고 얘기합니다.
그러면 여러분이 여러 아이디어를 사용해서 전략을 정의할 수 있습니다. ‘어떤 순서대로 내가 펼칠 것이다.’ 그런 전략을 정의할 수 있는데요.
그 수많은 다른 전략 중에서 뭐가 더 좋은지를 판단하기 위해서는 어떤 구성요소가 필요하겠죠. 그러니까 어떤 기준으로 이 전략을 판단하겠다.
일반적으로 크게 4가지 기준으로 전략을 판단합니다. 첫 번째는 Completeness, 그러니까 완전성입니다. 내가 만약에 이 전략을 따른다면 반드시 solution을 찾을 수 있느냐?
만약에 Completeness에 대한 답이 Yes라고 하면 이 전략을 사용했을 때 만약에 해가 존재한다면 반드시 내가 찾을 수 있다. 이렇게 얘기할 수 있겠죠.
그래서 전략들 중에 Completeness를 만족하는 전략이 더 좋다고 할 수 있습니다. 왜냐하면, 내가 이 전략을 선택하는 순간 내가 해를 찾을 수 있다는 게 보증이 되기 때문입니다.
두 번째 요소는 Time complexity입니다. 이건 시간 복잡도라는 건데요.
우리가 노드 하나하나를 goal인지 아닌지 판단하는 데 똑같은 시간이 걸린다면, 결국 Time complexity라는 건 우리가 얼마큼의 노드를 펼쳐야지만 goal을 찾을 수 있느냐를 나타낸다고 할 수 있겠죠.
그게 기준이라고 한다면 당연히 Time complexity가 낮은 전략을 쓰는 게 좋을 것입니다.
Space complexity는 뭐냐 하면, 여러분이 노드를 하나씩 펼쳐나갈 텐데 여러분이 펼쳐만 놓고 그 노드를 자세히 탐색을 안 했다면 그건 메모리상에 저장을 해놓아야 됩니다.
왜냐하면 나중에 그 노드를 펼쳐봐야 되기 때문에. 그런 식으로 내가 어떤 전략을 썼을 때 메모리 공간이 얼마나 필요하냐? 이걸 Space complexity라고 정의를 하고요.
그리고 전략들 중에 당연히 Space complexity가 낮은 전략이 더 좋다고 할 수 있겠죠.
Optimality는 뭐냐? Completeness보다 좀 더 나아간 기준이라고 볼 수 있는데요. 내가 항상 최적의 solution을 찾을 수 있느냐?
그러니까 내가 Arad까지 갈 수 있는 수많은 Path들이 있는데, 내가 이 전략을 쓴다면 최적으로 갈 수 있는 solution을 내가 찾을 수 있느냐? 그거에 대한 기준이라고 할 수 있습니다.
그래서 결국에 Optimality도 Yes가 되면 제일 좋다고 할 수 있겠죠. 그런데 여러분이 생각을 해보시면 아실 수 있겠지만, 모든 전략 중에서 서로 trade off가 있습니다.
어떤 전략은 어떤 측면에서는 더 좋고요. 또 다른 전략은 그 측면에서는 안 좋지만 또 다른 측면에서는 좋고요.
그래서 많은 경우에 여러분이 문제에 따라서 적절한 전략을 선택하는 것이 매우 중요합니다.
그래서 탐색 전략에 대해서 좀 자세히 다루려고 합니다. 탐색 전략 중에서 가장 먼저 생각해볼 수 있는 건 Uninformed search라는 전략입니다.
이건 좀 전에 말씀드린 문제 정의의 4가지 구성요소에서 주어진 정보만을 활용해서 탐색을 하는 전략들을 Uninformed search라고 합니다.
다음 시간에는 Heuristic을 이용한 search에 대해서도 얘기할 예정인데, 이번 시간에는 Uninformed search에 집중해서 말씀드리고자 하고요.
그리고 Uninformed search의 대표적인 5개는 지금 보여드린 이와 같습니다.
그런데 여기서 보시다시피 5개의 서로 다른 대표적인 Uninformed search 전략들이 있긴 하지만, 얘네들도 결국에 크게 보면 두 가지 탐색 전략으로부터 유래됐다고 할 수 있습니다.
그 두 가지 탐색 전략이란 Breadth-first search와 Depth-first search를 얘기합니다.
Breadth-first search라는 건 많은 경우에 BFS라고 약자로 쓰기도 하고요. 한국말로는 ‘너비 우선 탐색’이라고 얘기합니다.
Depth-first search는 DFS라고 많이 요약을 해서 얘기를 하고요. 한국어로는 ‘깊이 우선 탐색’이라고 얘기합니다.
그래서 이 뒤에 나온 Depth-limited search라든지 Iterative deepening search는 다 Depth-first search를 기반으로 해서 그걸 좀 더 개선한 알고리즘이라고 할 수 있겠고요.
Uniform-cost search도 Breadth-first search를 좀 더 변형한 탐색 전략이라고 이해하시면 되겠습니다.
사실 이 5개에 대해서 다 다루는 게 아주 재미있긴 하지만, 본 강의에서는 가장 기본이 되는 Breadth-first search와 Depth-first search에 대해서 깊이 다루도록 하겠습니다.
그럼 우선적으로 Breadth-first search, 그러니까 너비우선탐색이라는 전략에 대해서 소개를 시켜드리도록 하겠습니다.
기본 아이디어는 이와 같습니다. 만약에 주어진 노드가 있고 아직 펼쳐지지 않은 노드들이 있다고 하면, 가장 얕은 아직 펼쳐지지 않은 노드부터 펼치자. 그런 전략이라고 할 수 있겠습니다.
그리고 이런 경우에 Breadth-first search는 FIFO라는 데이터 구조로 구현이 가능한데요. FIFO는 무슨 뜻이냐 하면, First In First Out입니다.
그래서 ‘처음 들어간 게 먼저 나온다. 먼저 들어간 게 먼저 나온다.’ 이런 철학을 가진 데이터 구조라고 할 수 있습니다.
여기서 Fringe라는 단어는 뭐냐 하면, 아까 말씀드린 대로 일단 노드가 나오긴 했지만 아직 펼쳐지지 않은 노드들을 Fringe라고 얘기합니다.
그래서 과연 이 Breadth-first search가 어떻게 동작이 되고, 이게 어떻게 FIFO라는 queue를 통해서 구현이 되는지 하나하나씩 말씀을 드리도록 하겠습니다.
그러면 이제 루트부터 하나씩 가보도록 하죠. 여기서 루트 노드라는 건 결국 Initial state가 되겠죠. Initial state가 여기서는 A라는 게 되겠죠.
그러면 Initial state를 일단 FIFO, 그러니까 First In First Out이라는 queue에 넣었습니다. 그러면 여기 보시다시피 A라는 노드가 queue 안에 존재하게 되겠죠.
그러면 그다음 스텝으로 넘어가도록 하겠습니다. 여기서 지금 A라는 노드가 queue 사이에 있기 때문에 A라는 걸 하나 빼는 것이죠.
A를 빼고 A에서 갈 수 있는 게 여기 보시다시피 B와 C라는 노드가 있습니다.
그러면 A라는 노드를 queue에서 뺀 다음에 ‘얘가 goal이냐 아니냐?’를 판단하고 ‘goal이 아니다.’, ‘그렇다면 여기서 갈 수 있는 state가 뭐냐?’ 그걸 찾은 다음에 그 각각을 queue에 넣습니다.
그러니까 지금 A라는 Initial state로 queue에 넣었다가 그걸 빼서 goal인지 판단하고 펼치는 순간 이제 A는 탐색이 다 됐기 때문에 queue에서 버려지게 됩니다.
그래서 A는 버려지고 B와 C라는 노드가 queue상에 존재하게 되겠죠.
그러면 First In First Out이기 때문에 여기서 B와 C 중에 앞에 있는 것이 무엇이죠? 앞에 있는 게 B입니다. 그래서 B를 그다음에 빼내봅니다.
그래서 B를 빼내서 ‘그럼 B가 지금 Goal state냐?’, ‘아니다.’, ‘그러면 B에서 갈 수 있는 노드가 어떤 것들에 있느냐?’ 이 Example에서는 D와 E가 있겠죠.
그러면 B를 판단해서 봤더니 D와 E라는 노드가 새로 생겨나게 되고요. D라는 노드를 queue에 넣고 E라는 노드를 queue에 넣고 이제 B라는 노드는 버려지게 되겠죠.
그럼 결과적으로 queue에는 C, D, E가 남아있게 되죠. 그런데 여기 queue에 C, D, E라는 세 가지 요소가 있는데, 이 중에서 가장 먼저 들어온 게 무엇이죠?
가장 먼저 들어온 게 C였죠. B가 들어온 다음에 C가 들어왔고, 그다음에 B를 판단한 다음에 D와 E가 queue 사이에 들어왔습니다.
그렇다면 가장 먼저 들어온 애가 C이기 때문에 C를 마찬가지로 판단을 하게 되겠죠.
그래서 C를 queue에서 빼낸 다음에 ‘이게 골이냐 아니냐?’를 판단하고, 만약에 ‘아니다.’라고 하면 ‘C에서 도달할 수 있는 state가 뭐냐?’ 봤더니 F랑 G다. 그러면 이 F랑 G가 queue에 들어가게 되겠죠.
그러면 C는 버려지고 D, F는 뒤에 붙어 있었고, F랑 G가 들어가니까 결국에는 C, E, F, G라는 요소들이 queue에 존재하게 되겠죠.
이 상황에서 다음에 또 search를 해나간다고 하면 어떤 노드부터 evaluation이 될까요? 그건 당연히 D부터 나오겠죠.
그래서 좀 전에 말씀드린 대로 D라는 노드를 또 queue에서 제일 앞에 있는 노드이기 때문에 빼낸 다음에
그걸 또 마찬가지로 ‘goal이냐 아니냐?’ 만약에 goal이면 ‘solution을 찾았다.’ 이렇게 결론을 내릴 수가 있고요. goal이 아니다. 그러면 D에서 펼쳐질 수 있는 게 뭐냐?
그 노드들을 찾은 다음에 그걸 다시 queue의 뒷부분에 넣어주면, 이런 식으로 계속 반복을 해주면 결국에 Breadth-first search를 수행할 수 있게 됩니다.
지금 말씀드린 내용을 보시면, FIFO라는 데이터 구조, 그러니까 First In First Out을 통해서 저희가 탐색 전략을 구현했는데요.
이 전략대로 하다 보니까 A를 먼저 탐색하고, 그다음 B 탐색하고, 그다음에 B로부터 D, E가 펼쳐져 있긴 하지만 D, E, C 중에서 그다음에 C를 먼저 펼치게 됩니다.
그러니까 이 FIFO queue대로 전략을 구현하다 보면, 자연스럽게 같은 depth, 같은 깊이에 있는 노드를 일단 다 펼쳐보고
goal인지 아닌지 판단을 한 다음에 다음 depth로, 다음 깊이로 넘어가는 걸 여러분이 아실 수가 있겠죠.
그렇기 때문에 Breadth-first search, 그러니까 너비우선탐색이라는 이름이 붙게 된 것입니다.
루트를 검색하고요. 그다음에 depth1. 그러니까 루트에서 갈 수 있는 노드들이 depth1에 위치하겠죠.
그 노드들을 다 goal인지 아닌지 판단하고 펼치고 난 다음에야 depth2, 두 번째 깊이에 있는 노드들을 하나하나씩 펼쳐나가게 되겠죠.
그래서 이걸 Breadth-first search라고 하고, Breadth-first search는 고민할 거 없이 여러분이 FIFO라는 data structure, 데이터 구조를 활용하면 아주 쉽게 구현할 수 있다는 것입니다.
그러면 지금까지 너비우선탐색에 대해서 말씀을 드렸고요. 이제는 깊이우선탐색에 대해서 말씀을 드리도록 하겠습니다.
깊이우선탐색은 이름에서도 아실 수 있다시피 가장 깊은 아직 펼쳐지지 않은 노드들부터 하나하나씩 체크하고 펼쳐나가겠다. 그런 아이디어입니다.
Breadth-first search 같은 경우에 가장 낮은 shallow unexpanded node를 찾았다고 하면, 여기에서는 deepest unexpanded node를 찾는다고 보시면 되겠고요.
구현은 어떻게 하느냐? LIFO라는 data structure를 이용하면 됩니다. LIFO는 Last In First Out입니다.
그러니까 가장 늦게 들어간 애가 가장 먼저 나오는 식으로 데이터 구조가 구성되어 있다고 보시면 되겠습니다.
여기서도 마찬가지로 아주 간단한 예제와 함께 깊이우선탐색에 대해서 말씀을 드리고자 합니다.
시작점은 Initial state죠? 여기서는 Initial state가 A이기 때문에 A가 LIFO, 그러니까 Last In First Out queue에 이제 들어가게 됩니다.
그래서 이렇게 넣어놓은 상태에서 queue 안에 있는, 가장 앞에 있는 요소를 끄집어냅니다. 그럼 A를 끄집어내서 ‘A가 goal이냐 아니냐?’ 판단을 하고요.
goal이 아니라고 하면 얘가 갈 수 있는, 여기서부터 펼쳐질 수 있는 노드가 뭐냐? 그랬더니 B와 C다. 그렇게 이제 판단이 되고요.
그런데 B, C가 함께 같이 펴진 거잖아요. A로부터 B, C가 같이 펴졌는데, 이해를 좀 쉽게 하기 위해서 이 둘 중에 어떤 걸 먼저 넣을까 할 때 C부터 넣고 B를 넣었다고 한번 가정을 해보죠.
그러면 이와 같이 되겠죠. C를 넣은 다음에 B를 넣었습니다. 아까 같은 경우에는 뒤를 통해서 B, C가 들어갔다고 하면, 여기서는 앞을 통해서 B, C가 들어갔다고 할 수 있겠죠.
왜냐하면 Last In First Out이기 때문에 가장 늦게 들어간 애가 앞에 위치해야 됩니다.
그런데 여기서는 A에서 펼쳐질 수 있는 게 B, C였는데, 저희가 편의상 둘 중에 C부터 넣고 그다음에 B를 넣었다고 가정을 해보죠.
그런 식으로 했다고 하면 지금 B와 C가 queue상에 존재합니다. 그러면 C부터 넣은 다음에 B를 넣기 때문에 Last In이 B입니다. 그러면 Last In이 First Out 해야 되기 때문에 B가 이제 나옵니다.
그럼 B가 나와서 마찬가지로 evaluation 과정을 거칩니다. 그래서 B가 goal이냐 아니냐? 아니다. 그럼 B에서 도달할 수 있는 state가 뭐냐? D와 E다.
그런데 좀 전에도 말씀드렸다시피 D, E 중에 E부터 한번 넣죠. E부터 넣고 D를 넣었다고 가정을 해보시죠.
그럼 결국에는 B랑 C가 있었는데 B가 빠져나왔고요. 거기서부터 D와 E가 나왔는데 E를 넣고 D를 넣었습니다.
아까도 말씀드렸다시피 여기서는 들어가는 게 앞을 통해서 들어갑니다. 그래서 C가 있었는데 E를 넣고 D를 넣었습니다.
그럼 여기서 가장 늦게 들어간 게 D고요. 그렇기 때문에 D가 가장 먼저 나와야 됩니다. 그리고 queue상에서 가장 앞에 위치하게 되겠고요.
그래서 D도 마찬가지 과정을 거칩니다. D를 다시 빼낸 다음에 D가 goal이냐 아니냐? 아니다. 여기서 펼쳐질 수 있는 게 뭐냐? H랑 I다.
그러면 좀 전에 말씀드렸다시피 I를 넣고 H를 넣고요. 그러면 H부터 나와서 evaluation을 수행하게 됩니다.
결국에 H, I, E, C가 queue상에 존재하게 되죠. 이 상황에서 또 이 과정을 반복합니다. 그러면 H가 나오고요. H가 나왔는데 이게 goal이냐 아니냐? 그래서 아니라고 판단이 됐고요.
그런데 여기서 보시다시피 H에서는 더 이상 펼쳐질 수 있는 노드가 없습니다. 그러면 H가 나와서 goal이냐 아니냐? 아니다. 그러면 이제 더 이상 넣는 거 없이 I, E, C가 되는 것이죠.
이제 LIFO에는 I, E, C가 되고요. 그럼 여기서 가장 앞에 있는 게 I이기 때문에 I가 또 나옵니다. 그러면 I가 나와서 goal이냐 아니냐? 아니다. 또 펼쳐질 수 있는 게 없다.
그럼 이제 결국에 E와 C가 남고요. E와 C가 남은 상태에서 또 마찬가지로 E를 빼내고 E가 goal이냐 아니냐? 아니다.
그런데 여기서는 이제 또 펼쳐질 수 있는 게 있죠. J와 K가 펼쳐질 수 있는데, 이 상태에서 C만 남아있는 queue에서 K를 앞으로 넣고요. 그다음에 J를 앞으로 넣는다고 하면 J, K, C가 되겠고요.
또 이 과정을 계속 반복하게 됩니다. 그래서 J를 판단하고요. J가 goal이 아니었고, K도 goal이 아니었고요. 그러면 이제 또 C가 되고요.
이런 식으로 하면 B로부터 펼쳐질 수 있는 건 이미 다 검색이 됐는데, C쪽은 전혀 검색이 안 된 것입니다.
그러니까 Depth-first search는 어떤 특정한 Path를 정해서 끝까지 가보는 것입니다. 끝까지 가서 goal이 나올 때까지 혹은 더 이상 펼쳐지는 게 없을 때까지 가보고요.
만약에 goal이 아니었다고 판단하면 다시 올라와서 다시 깊이로 끝까지 가고요. 이 과정을 반복을 하게 됩니다. 그래서 뒤에 있는 부분은 여러분이 쉽게 응용을 할 수 있겠죠.
그래서 C로부터 펼쳐질 수 있는 노드가 F와 G가 되고요. 그게 LIFO queue에 저장이 되고요. F부터 시작해서 앞서 말씀드린 과정을 반복하게 됩니다.
F가 goal인지 판단을 하고, 그다음에 펼치고요. 그다음에 L, M이 새로 나왔고요. L이 goal인지 아닌지 판단을 하고, 아니라고 하면 M에 대해서 판단을 하고요.
그래서 이 과정을 계속해서 반복을 하다 보면, 결국에는 모든 search space를 다 찾을 수 있게 되겠죠.
좀 전에 말씀드린 Breadth-first search랑 Depth-first search를 비교해보시면, 너비우선탐색은 어떻게 보면 Initial state에서 도달할 수 있는 가장 가까운 영역부터 샅샅이 다 찾는 거고요.
그리고 깊이우선탐색 같은 경우에는 어떻게 보면 하나의 Path를 정해서 그 Path로 끝까지 한번 가보는 것이죠. goal이 됐든 goal이 되지 않았든.
그거에 대해서 판단을 하고, 그다음에 거기서 goal을 찾으면 다행인데 만약 goal을 못 찾았다. 그럼 다시 위로 올라와서 찾는 이런 과정을 반복하게 되는 것입니다.
그러면 마지막으로 BFS(너비우선탐색)과 DFS(깊이우선탐색)을 요약해서 말씀드리도록 하겠습니다.
아까도 말씀드렸다시피 어떤 탐색 전략을 판단하는 기준은 크게 많이 사용되는 게 4가지라고 말씀을 드렸고요.
이 4가지 특성을 하나로 요약한 표를 여러분이 보시는 것입니다. 그래서 완전성이 있느냐 했을 때 BFS는 Yes입니다.
그러니까 BFS를 쓰면 시간이 얼마 걸리든지 간에 이 전략을 계속 쓰다 보면 결국에 해를 찾을 수 있다는 거고요.
DFS는 애석하게도 No입니다. 그러니까 좀 전에 보셨다시피 만약에 우리가 왼쪽 Path로 계속 끝까지 가게 되는데,
재수가 없는 경우에는 어떤 state를 갔다가 다시 돌아오는 경우도 있습니다. 계속 사이클을 그리면서 돌아오는 경우가 있는데요.
실제로는 오른쪽 Path를 통해서 가야지 goal이 있는데 왼쪽 Path를 취했고, 그런데 계속 가다 보면 그리고 거기서 어떤 루프에 빠진다고 하면 결국에 Completeness를 만족하지 않게 되겠죠.
그다음에 여기 보시면 Time complexity와 Space complexity가 있는데요. 되게 복잡한 notation으로 되어 있습니다.
알파벳 대문자로 O라고 되어 있고요. 그 안에 어떤 기호로 수식이 표현되어 있는데요.
이 O라는 건 복잡도를 나타내는 notation 중에 하나입니다. 그래서 Big-O notation이라고 일반적으로 얘기하는 방식이고요.
이건 여러분이 만약에 알고리즘에 대해서 공부를 하셨다면 배우셨을 거라고 생각이 되고요.
혹시 알고리즘을 배우시지 않았더라면 지금은 그냥 한번 넘어가시고 나중에 혹시 알고리즘을 알게 되면 다시 한 번 보시는 게 좋지 않을까 생각이 됩니다.
그래서 여기 여러 가지 기호가 있는데, b는 한 노드에서 펼쳐질 수 있는 최대의 숫자입니다. 그러니까 최대로 펼쳐질 수 있는 branch 수고요.
그다음에 d라는 건 goal이 있는 depth입니다. m이라는 건 search를 하게 될 depth입니다.
그래서 이렇게 보시면 좀 복잡하게 느껴지실 수도 있는데, 간단히만 말씀을 드리면 Breadth-first search는 Completeness에서는 장점이 있긴 하지만 알고리즘 자체가 복잡합니다.
그러니까 시간도 더 많이 걸리고, 메모리 공간도 훨씬 많이 차지하게 되죠.
그런데 Depth-first search는 해를 찾을 수 있다는 걸 guarantee, 보장은 못해 주지만, 한결 한결 특히 space complexity 관점에서는 훨씬 효율적인 알고리즘이라고 보시면 되겠습니다.
그리고 마지막 Optimality라는 요소가 있는데요. Optimality는 BFS 같은 경우에는 Yes지만 DFS 같은 경우에는 No입니다.
사실 이 4가지 기준에 대해서 이 결과가 어떻게 나왔는지 한번 유도해보는 것도 재미있는 문제이긴 한데,
시간관계상 여기서 다루지는 않습니다만 여러분이 혹시 관심이 있으시다면 웹에서 충분히 어떻게 유도하는지 과정을 쉽게 공부하실 수 있기 때문에 여러분에게 숙제로 남겨두도록 하겠습니다.
그런데 마지막으로 좀 전에도 시작하기 전에 말씀드렸다시피 오늘 강좌에서는 Uninformed search 전략에 대해서만 말씀을 드렸습니다.
그런데 이 Uninformed search 말고 여러 가지 다른 정보를 활용하는 Heuristic search라는 게 있는데요.
Heuristic search을 활용하면 지금 말씀드린 Uninformed search보다는 훨씬 더 쉽게 solution을 찾을 수가 있습니다. 그래서 다음 시간에는 그거에 대해서 주로 다룰 예정이고요.
그리고 그렇다 하더라도 지금 말씀드린 Breadth-first search, Depth-first search는 Heuristic search에서도 계속 사용될 거기 때문에
기본 개념을 이해하는 측면에서는 반드시 알아두어야 할 탐색 전략이라고 할 수 있겠습니다.
그러면 오늘의 강의는 여기서 마치도록 하겠고요. 다음 강좌를 통해서 다시 만나 뵙도록 하겠습니다.